///<reference path="references.all.ts"/>

var
    PluginError = require('gulp-util').PluginError
    , path   = require('path')
    , fs     = require('fs')
    , os     = require('os')
    , through = require('through2')
    ;

interface IAttributes {
    src: string;
    content: string;
    [name: string]: string;
}

interface IOptions {
    tagName: string;
    autoIndent: boolean;
    prefixVar: string;
}

class GulpHtmlTagIncludePlugin {
    static PLUGIN_NAME = 'gulp-html-tag-include';
    private stackPath: string[] = [];

    options: IOptions = { tagName: 'include', autoIndent: true, prefixVar: '@@' };
    directiveRegexp: RegExp;

    constructor(options: IOptions) {
        if (options) {
            this.options.tagName = options.tagName || this.options.tagName;
            this.options.autoIndent = options.autoIndent || this.options.autoIndent;
            this.options.prefixVar = options.prefixVar || this.options.prefixVar;
        }
        this.directiveRegexp = RegExp('<' + this.options.tagName + '\\s+([\\s\\S]*?)>([\\s\\S]*?)<\\/' + this.options.tagName + '>', 'gi');
    }

    getFileContent(file) {
        if (!fs.existsSync(file) )
            throw new PluginError(GulpHtmlTagIncludePlugin.PLUGIN_NAME, 'File not found: ' + file);

        return fs.readFileSync(file, { encoding: 'utf8' });
    }

    execute(file: string, content: string): string {
        this.stackPath = [];
        return this.processingContent({ src: path.basename(file), content: '' }, path.normalize(file), content);
    }

    private extractAttributes(attrs: string): IAttributes {
        var attributeRegexp = /\s*(\S+)="([\s\S]*?)"/gi;
        var result: IAttributes = { src: '', content: '' };
        var match;

        while (match = attributeRegexp.exec(attrs)) {
            var attr = match[1] || '';
            var value = match[2] || '';

            if (attr) result[attr] = value;
        }
        return result;
    }

    private processingContent(attributes: IAttributes, parentFile: string, fileContent?: string, indent?: string): string {
        if (!attributes.src) {
            throw new PluginError(GulpHtmlTagIncludePlugin.PLUGIN_NAME, 'Not specified attribute "src" in file "' + parentFile + '"');
        }
        var file = path.normalize(path.dirname(parentFile) + path.sep + attributes.src);

        //check looping
        if (this.stackPath.indexOf(file) > -1) {
            throw new PluginError(GulpHtmlTagIncludePlugin.PLUGIN_NAME, ['Looping include', os.EOL, 'Stack path:', os.EOL, this.stackPath.join(os.EOL)].join(''));
        }
        this.stackPath.push(file);

        if (typeof fileContent === 'undefined') {
            fileContent = this.getFileContent(file);
        }

        if (indent) {
            fileContent = fileContent.replace(/(\n|\r\n)(.+)/g, '$1' + indent + '$2');
        }

        fileContent = this.replaceAttributes(attributes, fileContent);
        fileContent = this.replaceInclude(file, fileContent);

        this.stackPath.pop();
        return fileContent;
    }

    private replaceAttributes(attributes: IAttributes, fileContent: string): string {
        var varRegexp = RegExp(this.options.prefixVar + '(\\w+)', 'gi');
        return fileContent.replace(varRegexp, (match, attr) => {
            return attributes[attr] || '';
        });
    }

    private replaceInclude(parentFile: string, fileContent: string): string {
        return fileContent.replace(this.directiveRegexp, (match, attrs, content, offset) => {
            var indent;
            var attributes = this.extractAttributes(attrs);
            attributes.content =  content;

            if (this.options.autoIndent) {
                indent = this.getIndent(fileContent, offset - 1)
            }
            return this.processingContent(attributes, parentFile, undefined, indent);
        });
    }

    private getIndent(content, offset) {
        var result = '';
        while (offset >= 0) {
            var char = content[offset];
            if (char !== ' ' && char !== '\t') break;

            result += char;
            offset--;
        }
        return result;
    }
}

function gulpHtmlTagInclude(options) {
    var gulpPlugin = new GulpHtmlTagIncludePlugin(options);

    return through.obj(function(file, enc, cb) {
        var content;

        if (file.isStream()) {
            this.emit('error', new PluginError(GulpHtmlTagIncludePlugin.PLUGIN_NAME, 'Stream content is not supported'));
            return cb(null, file);
        }

        if (file.isBuffer()) {
            try {
                content = gulpPlugin.execute(file.path, file.contents.toString('utf8'));
                file.contents = new Buffer(content);
            } catch (err) {
                this.emit('error', new PluginError(GulpHtmlTagIncludePlugin.PLUGIN_NAME, err));
            }
        }

        this.push(file);
        return cb();
    });
}

module.exports = gulpHtmlTagInclude;